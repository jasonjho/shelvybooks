import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/hooks/use-toast';
import { BookClub, BookClubMember, BookClubSuggestion } from '@/types/bookClub';

// Extended member type with profile info
export interface ClubMemberWithProfile extends BookClubMember {
  displayName: string | null;
  shareId: string | null;
  isPublic: boolean;
}

// Vote with user info
export interface VoteWithUser {
  id: string;
  suggestionId: string;
  userId: string;
  displayName: string | null;
  shareId: string | null;
  isPublic: boolean;
}

export function useBookClubs() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [clubs, setClubs] = useState<BookClub[]>([]);
  const [loading, setLoading] = useState(true);

  // Fetch user's clubs
  useEffect(() => {
    if (!user) {
      setClubs([]);
      setLoading(false);
      return;
    }

    const fetchClubs = async () => {
      setLoading(true);
      
      // Get clubs where user is a member
      const { data: memberData, error: memberError } = await supabase
        .from('book_club_members')
        .select('club_id')
        .eq('user_id', user.id);

      if (memberError) {
        console.error('Error fetching memberships:', memberError);
        setLoading(false);
        return;
      }

      const clubIds = memberData.map(m => m.club_id);
      
      if (clubIds.length === 0) {
        setClubs([]);
        setLoading(false);
        return;
      }

      const { data: clubData, error: clubError } = await supabase
        .from('book_clubs')
        .select('*')
        .in('id', clubIds)
        .order('created_at', { ascending: false });

      if (clubError) {
        console.error('Error fetching clubs:', clubError);
        toast({
          title: 'Error loading clubs',
          description: clubError.message,
          variant: 'destructive',
        });
      } else {
        setClubs(
          clubData.map((row) => ({
            id: row.id,
            name: row.name,
            description: row.description,
            inviteCode: row.invite_code,
            ownerId: row.owner_id,
            createdAt: row.created_at,
          }))
        );
      }
      setLoading(false);
    };

    fetchClubs();
  }, [user, toast]);

  const createClub = useCallback(
    async (name: string, description?: string): Promise<BookClub | null> => {
      if (!user) {
        toast({
          title: 'Sign in required',
          description: 'Please sign in to create a club.',
          variant: 'destructive',
        });
        return null;
      }

      // Create the club
      const { data: clubData, error: clubError } = await supabase
        .from('book_clubs')
        .insert({
          name,
          description: description || null,
          owner_id: user.id,
          invite_code: '', // Will be generated by trigger
        })
        .select()
        .single();

      if (clubError) {
        console.error('Error creating club:', clubError);
        toast({
          title: 'Error creating club',
          description: clubError.message,
          variant: 'destructive',
        });
        return null;
      }

      // Add creator as owner member
      const { error: memberError } = await supabase
        .from('book_club_members')
        .insert({
          club_id: clubData.id,
          user_id: user.id,
          role: 'owner',
        });

      if (memberError) {
        console.error('Error adding owner as member:', memberError);
      }

      const newClub: BookClub = {
        id: clubData.id,
        name: clubData.name,
        description: clubData.description,
        inviteCode: clubData.invite_code,
        ownerId: clubData.owner_id,
        createdAt: clubData.created_at,
      };

      setClubs((prev) => [newClub, ...prev]);

      toast({
        title: 'Club created!',
        description: `"${name}" is ready. Share the invite link with friends!`,
      });

      return newClub;
    },
    [user, toast]
  );

  const joinClub = useCallback(
    async (inviteCode: string): Promise<BookClub | null> => {
      if (!user) {
        toast({
          title: 'Sign in required',
          description: 'Please sign in to join a club.',
          variant: 'destructive',
        });
        return null;
      }

      // Use secure RPC function to lookup club by invite code
      const { data: clubData, error: clubError } = await supabase
        .rpc('lookup_club_by_invite_code', { _invite_code: inviteCode });

      if (clubError || !clubData || clubData.length === 0) {
        toast({
          title: 'Club not found',
          description: 'Check the invite code and try again.',
          variant: 'destructive',
        });
        return null;
      }

      const foundClub = clubData[0];

      // Check if already a member
      const { data: existingMember } = await supabase
        .from('book_club_members')
        .select('id')
        .eq('club_id', foundClub.id)
        .eq('user_id', user.id)
        .maybeSingle();

      if (existingMember) {
        toast({
          title: 'Already a member',
          description: `You're already in "${foundClub.name}"!`,
        });
        // Return minimal info since we don't have full club data from the secure lookup
        return {
          id: foundClub.id,
          name: foundClub.name,
          description: null,
          inviteCode: inviteCode,
          ownerId: '', // Not exposed by secure lookup
          createdAt: '',
        };
      }

      // Join the club
      const { error: joinError } = await supabase
        .from('book_club_members')
        .insert({
          club_id: foundClub.id,
          user_id: user.id,
          role: 'member',
        });

      if (joinError) {
        console.error('Error joining club:', joinError);
        toast({
          title: 'Error joining club',
          description: joinError.message,
          variant: 'destructive',
        });
        return null;
      }

      // Now that we're a member, we can fetch full club details
      const { data: fullClubData } = await supabase
        .from('book_clubs')
        .select('*')
        .eq('id', foundClub.id)
        .single();

      const newClub: BookClub = {
        id: foundClub.id,
        name: foundClub.name,
        description: fullClubData?.description || null,
        inviteCode: fullClubData?.invite_code || inviteCode,
        ownerId: fullClubData?.owner_id || '',
        createdAt: fullClubData?.created_at || '',
      };

      setClubs((prev) => [newClub, ...prev]);

      toast({
        title: 'Joined club!',
        description: `Welcome to "${foundClub.name}"!`,
      });

      return newClub;
    },
    [user, toast]
  );

  const leaveClub = useCallback(
    async (clubId: string) => {
      if (!user) return;

      const club = clubs.find((c) => c.id === clubId);
      
      if (club?.ownerId === user.id) {
        toast({
          title: 'Cannot leave',
          description: 'You own this club. Delete it instead.',
          variant: 'destructive',
        });
        return;
      }

      const { error } = await supabase
        .from('book_club_members')
        .delete()
        .eq('club_id', clubId)
        .eq('user_id', user.id);

      if (error) {
        console.error('Error leaving club:', error);
        toast({
          title: 'Error leaving club',
          description: error.message,
          variant: 'destructive',
        });
        return;
      }

      setClubs((prev) => prev.filter((c) => c.id !== clubId));

      toast({
        title: 'Left club',
        description: club ? `You've left "${club.name}".` : 'You\'ve left the club.',
      });
    },
    [user, clubs, toast]
  );

  const updateClub = useCallback(
    async (clubId: string, name: string, description?: string): Promise<boolean> => {
      if (!user) return false;

      const { error } = await supabase
        .from('book_clubs')
        .update({
          name,
          description: description || null,
        })
        .eq('id', clubId);

      if (error) {
        console.error('Error updating club:', error);
        toast({
          title: 'Error updating club',
          description: error.message,
          variant: 'destructive',
        });
        return false;
      }

      setClubs((prev) =>
        prev.map((c) =>
          c.id === clubId ? { ...c, name, description: description || null } : c
        )
      );

      toast({
        title: 'Club updated',
        description: `"${name}" has been updated.`,
      });

      return true;
    },
    [user, toast]
  );

  const deleteClub = useCallback(
    async (clubId: string) => {
      if (!user) return;

      const club = clubs.find((c) => c.id === clubId);

      const { error } = await supabase
        .from('book_clubs')
        .delete()
        .eq('id', clubId);

      if (error) {
        console.error('Error deleting club:', error);
        toast({
          title: 'Error deleting club',
          description: error.message,
          variant: 'destructive',
        });
        return;
      }

      setClubs((prev) => prev.filter((c) => c.id !== clubId));

      toast({
        title: 'Club deleted',
        description: club ? `"${club.name}" has been deleted.` : 'Club has been deleted.',
      });
    },
    [user, clubs, toast]
  );

  return {
    clubs,
    loading,
    createClub,
    joinClub,
    leaveClub,
    updateClub,
    deleteClub,
  };
}

// Hook for a single club's details
export function useClubDetails(clubId: string | undefined) {
  const { user } = useAuth();
  const { toast } = useToast();
  const [club, setClub] = useState<BookClub | null>(null);
  const [members, setMembers] = useState<ClubMemberWithProfile[]>([]);
  const [suggestions, setSuggestions] = useState<BookClubSuggestion[]>([]);
  const [votes, setVotes] = useState<VoteWithUser[]>([]);
  const [loading, setLoading] = useState(true);
  const [isOwner, setIsOwner] = useState(false);

  const fetchClubData = useCallback(async () => {
    if (!clubId || !user) {
      setLoading(false);
      return;
    }

    setLoading(true);

    // Fetch club
    const { data: clubData, error: clubError } = await supabase
      .from('book_clubs')
      .select('*')
      .eq('id', clubId)
      .maybeSingle();

    if (clubError || !clubData) {
      console.error('Error fetching club:', clubError);
      setLoading(false);
      return;
    }

    setClub({
      id: clubData.id,
      name: clubData.name,
      description: clubData.description,
      inviteCode: clubData.invite_code,
      ownerId: clubData.owner_id,
      createdAt: clubData.created_at,
    });

    setIsOwner(clubData.owner_id === user.id);

    // Fetch members with their shelf settings
    const { data: memberData } = await supabase
      .from('book_club_members')
      .select('*')
      .eq('club_id', clubId);

    if (memberData) {
      // Get shelf settings for all members
      const memberIds = memberData.map(m => m.user_id);
      const { data: shelfData } = await supabase
        .from('shelf_settings')
        .select('user_id, display_name, share_id, is_public')
        .in('user_id', memberIds);

      const shelfMap = new Map<string, { displayName: string | null; shareId: string | null; isPublic: boolean }>();
      shelfData?.forEach(s => {
        shelfMap.set(s.user_id, {
          displayName: s.display_name,
          shareId: s.share_id,
          isPublic: s.is_public,
        });
      });

      setMembers(
        memberData.map((m) => {
          const shelf = shelfMap.get(m.user_id);
          return {
            id: m.id,
            clubId: m.club_id,
            userId: m.user_id,
            role: m.role as 'owner' | 'member',
            joinedAt: m.joined_at,
            displayName: shelf?.displayName || null,
            shareId: shelf?.shareId || null,
            isPublic: shelf?.isPublic || false,
          };
        })
      );
    }

    // Fetch suggestions with vote counts
    const { data: suggestionData } = await supabase
      .from('book_club_suggestions')
      .select('*')
      .eq('club_id', clubId)
      .order('created_at', { ascending: false });

    if (suggestionData) {
      // Get vote counts for each suggestion
      const suggestionsWithVotes = await Promise.all(
        suggestionData.map(async (s) => {
          const { count } = await supabase
            .from('book_club_votes')
            .select('*', { count: 'exact', head: true })
            .eq('suggestion_id', s.id);

          const { data: userVote } = await supabase
            .from('book_club_votes')
            .select('id')
            .eq('suggestion_id', s.id)
            .eq('user_id', user.id)
            .maybeSingle();

          return {
            id: s.id,
            clubId: s.club_id,
            title: s.title,
            author: s.author,
            coverUrl: s.cover_url,
            suggestedBy: s.suggested_by,
            status: s.status as 'suggested' | 'reading' | 'read',
            createdAt: s.created_at,
            voteCount: count || 0,
            hasVoted: !!userVote,
          };
        })
      );

      setSuggestions(suggestionsWithVotes);

      // Fetch all votes with user info
      const suggestionIds = suggestionData.map(s => s.id);
      const { data: allVotes } = await supabase
        .from('book_club_votes')
        .select('*')
        .in('suggestion_id', suggestionIds);

      if (allVotes && allVotes.length > 0) {
        // Get shelf settings for all voters
        const voterIds = [...new Set(allVotes.map(v => v.user_id))];
        const { data: voterShelfData } = await supabase
          .from('shelf_settings')
          .select('user_id, display_name, share_id, is_public')
          .in('user_id', voterIds);

        const voterShelfMap = new Map<string, { displayName: string | null; shareId: string | null; isPublic: boolean }>();
        voterShelfData?.forEach(s => {
          voterShelfMap.set(s.user_id, {
            displayName: s.display_name,
            shareId: s.share_id,
            isPublic: s.is_public,
          });
        });

        setVotes(
          allVotes.map(v => {
            const shelf = voterShelfMap.get(v.user_id);
            return {
              id: v.id,
              suggestionId: v.suggestion_id,
              userId: v.user_id,
              displayName: shelf?.displayName || null,
              shareId: shelf?.shareId || null,
              isPublic: shelf?.isPublic || false,
            };
          })
        );
      } else {
        setVotes([]);
      }
    }

    setLoading(false);
  }, [clubId, user]);

  useEffect(() => {
    fetchClubData();
  }, [fetchClubData]);

  const addSuggestion = useCallback(
    async (title: string, author: string, coverUrl?: string) => {
      if (!user || !clubId) return;

      const { data, error } = await supabase
        .from('book_club_suggestions')
        .insert({
          club_id: clubId,
          title,
          author,
          cover_url: coverUrl || null,
          suggested_by: user.id,
        })
        .select()
        .single();

      if (error) {
        console.error('Error adding suggestion:', error);
        toast({
          title: 'Error adding suggestion',
          description: error.message,
          variant: 'destructive',
        });
        return;
      }

      setSuggestions((prev) => [
        {
          id: data.id,
          clubId: data.club_id,
          title: data.title,
          author: data.author,
          coverUrl: data.cover_url,
          suggestedBy: data.suggested_by,
          status: data.status as 'suggested' | 'reading' | 'read',
          createdAt: data.created_at,
          voteCount: 0,
          hasVoted: false,
        },
        ...prev,
      ]);

      toast({
        title: 'Book suggested!',
        description: `"${title}" has been added to the suggestions.`,
      });
    },
    [user, clubId, toast]
  );

  const vote = useCallback(
    async (suggestionId: string) => {
      if (!user) return;

      const suggestion = suggestions.find((s) => s.id === suggestionId);
      if (!suggestion) return;

      if (suggestion.hasVoted) {
        // Remove vote
        const { error } = await supabase
          .from('book_club_votes')
          .delete()
          .eq('suggestion_id', suggestionId)
          .eq('user_id', user.id);

        if (error) {
          console.error('Error removing vote:', error);
          return;
        }

        setSuggestions((prev) =>
          prev.map((s) =>
            s.id === suggestionId
              ? { ...s, voteCount: (s.voteCount || 1) - 1, hasVoted: false }
              : s
          )
        );
      } else {
        // Add vote
        const { error } = await supabase
          .from('book_club_votes')
          .insert({
            suggestion_id: suggestionId,
            user_id: user.id,
          });

        if (error) {
          console.error('Error adding vote:', error);
          return;
        }

        setSuggestions((prev) =>
          prev.map((s) =>
            s.id === suggestionId
              ? { ...s, voteCount: (s.voteCount || 0) + 1, hasVoted: true }
              : s
          )
        );
      }
    },
    [user, suggestions]
  );

  const updateSuggestionStatus = useCallback(
    async (suggestionId: string, status: 'suggested' | 'reading' | 'read') => {
      if (!user || !isOwner) return;

      const { error } = await supabase
        .from('book_club_suggestions')
        .update({ status })
        .eq('id', suggestionId);

      if (error) {
        console.error('Error updating status:', error);
        toast({
          title: 'Error updating status',
          description: error.message,
          variant: 'destructive',
        });
        return;
      }

      setSuggestions((prev) =>
        prev.map((s) => (s.id === suggestionId ? { ...s, status } : s))
      );

      const suggestion = suggestions.find((s) => s.id === suggestionId);
      if (suggestion && status === 'reading') {
        toast({
          title: 'Now reading!',
          description: `"${suggestion.title}" is now the club's current read.`,
        });
      }
    },
    [user, isOwner, suggestions, toast]
  );

  const removeSuggestion = useCallback(
    async (suggestionId: string) => {
      if (!user) return;

      const { error } = await supabase
        .from('book_club_suggestions')
        .delete()
        .eq('id', suggestionId);

      if (error) {
        console.error('Error removing suggestion:', error);
        toast({
          title: 'Error removing suggestion',
          description: error.message,
          variant: 'destructive',
        });
        return;
      }

      setSuggestions((prev) => prev.filter((s) => s.id !== suggestionId));
    },
    [user, toast]
  );

  const updateClubDetails = useCallback(
    (name: string, description: string | null) => {
      setClub((prev) =>
        prev ? { ...prev, name, description } : prev
      );
    },
    []
  );

  return {
    club,
    members,
    suggestions,
    votes,
    loading,
    isOwner,
    addSuggestion,
    vote,
    updateSuggestionStatus,
    removeSuggestion,
    updateClubDetails,
    refetch: fetchClubData,
  };
}

// Hook to get all books from all user's clubs (for filtering personal shelf)
export interface ClubBook {
  title: string;
  author: string;
  clubId: string;
  clubName: string;
  status: 'suggested' | 'reading' | 'read';
}

export function useClubBooks() {
  const { user } = useAuth();
  const [clubBooks, setClubBooks] = useState<ClubBook[]>([]);
  const [clubsWithBooks, setClubsWithBooks] = useState<{ id: string; name: string }[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setClubBooks([]);
      setClubsWithBooks([]);
      setLoading(false);
      return;
    }

    const fetchClubBooks = async () => {
      setLoading(true);

      // Get all clubs user is a member of
      const { data: memberData } = await supabase
        .from('book_club_members')
        .select('club_id')
        .eq('user_id', user.id);

      if (!memberData || memberData.length === 0) {
        setClubBooks([]);
        setClubsWithBooks([]);
        setLoading(false);
        return;
      }

      const clubIds = memberData.map((m) => m.club_id);

      // Get club names
      const { data: clubData } = await supabase
        .from('book_clubs')
        .select('id, name')
        .in('id', clubIds);

      const clubMap = new Map<string, string>();
      clubData?.forEach((c) => clubMap.set(c.id, c.name));

      // Get all suggestions from those clubs
      const { data: suggestionsData } = await supabase
        .from('book_club_suggestions')
        .select('*')
        .in('club_id', clubIds);

      if (!suggestionsData) {
        setClubBooks([]);
        setClubsWithBooks([]);
        setLoading(false);
        return;
      }

      const books: ClubBook[] = suggestionsData.map((s) => ({
        title: s.title,
        author: s.author,
        clubId: s.club_id,
        clubName: clubMap.get(s.club_id) || 'Unknown Club',
        status: s.status as 'suggested' | 'reading' | 'read',
      }));

      // Get unique clubs that have books
      const uniqueClubs = Array.from(
        new Map(books.map((b) => [b.clubId, { id: b.clubId, name: b.clubName }])).values()
      );

      setClubBooks(books);
      setClubsWithBooks(clubData?.map((c) => ({ id: c.id, name: c.name })) || []);
      setLoading(false);
    };

    fetchClubBooks();
  }, [user]);

  // Check if a book (by title/author) is in any club
  const isBookInClub = useCallback(
    (title: string, author: string, clubId?: string) => {
      return clubBooks.some(
        (cb) =>
          cb.title.toLowerCase() === title.toLowerCase() &&
          cb.author.toLowerCase() === author.toLowerCase() &&
          (!clubId || cb.clubId === clubId)
      );
    },
    [clubBooks]
  );

  // Get club info for a book
  const getBookClubs = useCallback(
    (title: string, author: string) => {
      return clubBooks.filter(
        (cb) =>
          cb.title.toLowerCase() === title.toLowerCase() &&
          cb.author.toLowerCase() === author.toLowerCase()
      );
    },
    [clubBooks]
  );

  return {
    clubBooks,
    clubsWithBooks,
    loading,
    isBookInClub,
    getBookClubs,
  };
}
